## ⭐ 컬렉션의 의의
- 일정 작업을 빠르게 하기 위해서는 `자료구조`를 만들어서 이용해야함
- `자바`는 `컬렉션`을 통해 `자료구조`의 세세한 `구현`방법에 신경쓰지 않고, 미리 `구현`된 `객체`를 통해 `논리구조`에만 신경쓰면 될 수 있게 해줌

## ⭐ 각종 자료구조
### 📚 리스트
> 리스트는 슌서가 존재하는 인터페이스이다.

- 리스트는 특정 위치에 요소를 직접 삽입할 수 있다.
- 중복된 요소들을 허용한다.
- 리스트 요소의 위치값에 접근할 수 있는 네 가지 메소드를 제공한다.
#### 💬 리스트의 여러가지 메서드
- 리스트의 크기
- 리스트가 비어있는지 여부
- 리스트의 특정 위치에 어떤 요소가 들어가있는지
- 리스트가 특정 요소를 포함하고 있는지
- 리스트 안의 요소의 인덱스 번호
#### 💬 불변 리스트 vs 가변 리스트
> - List.of() 메서드를 통해 만든 리스트는 불변 리스트이다.

- 불변 리스트는 요소를 추가하거나, 삭제하는 것이 불가능하다.
- 리스트를 수정하기 위해서는 가변 리스트를 만들어야 한다.

#### 💬 가변 리스트의 종류
> 가변 리스트에는 `ArrayList`, `LinkedList`, `Vector`가 존재한다.

- `ArrayList`는 `배열`로 만들기 때문에, `특정 위치`에 있는 `값`에 접근하는게 빠르다.
  - 새로운 값이 입력되거나 삭제되었을 때, 배열 내 요소들을 전부 이동시켜야 하는 경우가 있어서, 새로운 값 입력 또는 삭제는 느리다.
- `LinkedList`는 `LinkedList`기반으로 만들어져 요소간에 앞-뒤가 있어서, 값을 추가하거나 삭제하는 것은 빠르다.
  - 그러나, 특정 인덱스 값에 접근하는 것은 `ArrayList`에 비해 느린편이다.

> `Vector`과 `ArrayList`는 똑같이 `Array`기반으로 만들어졌다.

- 차이점은 여러 스레드에서 한번에 접근이 가능한지 여부다.
  - `Vector`는 여러 스레드에서 접근이 불가능하게 `synchronized`구문으로 메서드를 만들어놨다.
  - 이렇게 하면 프로그램이 안전해진다.
  - `ArrayList`는 스레드 안전하지 않다. 여러 스레드에서 동시접근이 가능하기 때문이다.

#### 💬 Iterator
> `Iterator`는 리스트를 반복할 수 있는 또다른 방법이다

- `iterator.hasNext()`
  - 위 메서드를 통해 다음 요소가 있는지 검사할 수 있다.
- `iterator.next()`
  - 다음 요소를 불러온다.

> Iterator는 배열에서 요소를 제거할 때 사용하기 좋다.

- `{Bat,Apple,cat}`에서 at로 끝나는 단어를 제거하는 경우
	`for(String word: words)`의 경우 맨 뒤의 cat은 지워지지 않는다.
    `words.iterator()`로 만들고
    `while(wordsIterator.hasNext())`로 반복시킨뒤
    ```
    if(wordsIterator.next().endsWith("at")) {
    	wordsIterator.remove()
    }
    ```
    위와 같이 삭제를 한다.

> Iterator는 순회하는 도중에도 컬렉션을 안전하게 수정할 수 있는 장점이 있다.

  