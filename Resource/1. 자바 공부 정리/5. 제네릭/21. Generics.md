> ArrayList를 가진 클래스를 만들 때, String을 가진 ArrayLIst에 대한 클래스를 만들면, 다른 타입을 가진 ArrayList를 가진 클래스를 만들기 위해서는 새로 클래스를 만들어야 하는 문제가 있다.

# ❗문제가 있는 코드
```java
  
import java.util.ArrayList;  
  
public class MyCustomList {  
    ArrayList<String> list = new ArrayList();  
    public void addElement(String element){  
        list.add(element);  
    }  
  
    public void removeElement(String element){  
        list.remove(element);  
    }  
}
```

- 위와 같이 ArrayList에 String타입이 지정되어있어서 Integer를 요소로하는 ArrayList를 가진 클래스를 만들려먼 새로 클래스를 생성해야한다.

위와 같은 문제를 해결하기 위한 것이 바로 제네릭이다.

# 📖 제네릭 구현 코드
```java
package in28minutes.generics;  
  
import java.util.ArrayList;  
  
public class MyCustomList<T> {  
    ArrayList<T> list = new ArrayList();  
    public void addElement(T element){  
        list.add(element);  
    }  
  
    public void removeElement(T element){  
        list.remove(element);  
    }  
}
```

위와같이 구현하면 같은 함수를 가진 클래스를 타입에 따라 만들 수 있다.
`ArrayList`도 위와 같이 구현된 코드다

## ❗extends를 통해 타입을 한정할 수 있다
```java
  
public class MyCustomList<T extends Number> {  
    ArrayList<T> list = new ArrayList();  
    public void addElement(T element){  
        list.add(element);  
    }  
  
    public void removeElement(T element){  
        list.remove(element);  
    }  
}
```
- 위와 같이 구현한다면, Number를 상속받은 타입만 T타입에 들어갈 수 있다.

## ❗super로도 타입을 한정할 수 있다.

### `super`의 장점:

1. **부모 클래스에 대한 안정적인 저장:**
    
    - `<? super T>`를 사용하면 상위 클래스의 객체를 저장할 수 있습니다. 이는 상위 클래스의 메서드나 속성에만 접근해야 하는 상황에서 유용합니다.
2. **하위 클래스로부터 독립적인 코드:**
    
    - `<? super T>`는 클래스 계층 구조에서 독립적으로 작동하도록 하는데 도움이 됩니다. 코드가 특정 클래스 계층 구조에 의존하지 않고, 더 일반적인 상위 클래스로 작성될 수 있습니다.