# ⭐인터페이스란
> 인터페이스를 사용하는건 게임의 컨트롤러를 쓰는 것과 같다

- 옛날 콘솔게임의 컨트롤러는 `십자키`와 `A,B`키밖에 존재하지 않았다.
- 콘솔기기에 새로운 게임을 꽃으면, 기존에 있는 버튼에 게임에 따라 동작이 변화한다.
  - 마리오의 경우 `위로` 키를 누르면 `점프`를 한다.
  - 체스게임의 경우 `위로` 키를 누르면 체스말을 놓을 포인트를 위로 옮긴다.
- 위 예시의 컨트롤러가 인터페이스를 `사용`하는 클래스
- 마리오, 체스게임이 인터페이스를 `구현`하는 클래스라고 생각하자

### 💬 인터페이스의 변수선언
- 인터페이스에서 변수를 선언하고 값을 할당하면, 그 값은 상수가 된다.

### 💬 default 구현구문
- 자바8부터 도입된 기능 인터페이스에 구현을 집어넣을 수 있다.
- 따로 오버리아드해서 구현하지 않는 경우, 기본 인터페이스의 구현을 따라간다.

>왜 default구현이 필요할까?

- 기존 인터페이스를 사용하고 있던 클래스가 100개 존재한다면
  - 인터페이스에 새로운 메서드를 선언할 때, 아래 클래스에서 모두 새로운 메서드를 구현하라고 에러를 띄울 것이다.
  - 위와 같이 공통된 새로운 기능을 넣을 때, 모든 클래스를 수정하지 않고 기본적인 구현 구문을 제공함으로써, 수정이 필요한 클래스만 수정하여 사용할 수 있다.
  - 기본적으로 다른 메서드들을 건드리지 않기 때문에, 모든 클래스가 이 기능을 추가하는데 문제가 생기지 않는다.

# ⭐ 추상클래스
## 📚 추상클래스가 왜 필요한가?
> 그냥 클래스를 상속하는 것과는 무엇이 다른가?

- 만약 유닛이라는 공통 조상 `일반` 클래스가 존재한다고 생각해보자
  - 유닛은 움직일 수 있다.
  - 유닛은 공격할 수 있다.
- 유닛을 상속받은 마린, 유닛을 상속받은 배틀크루져가 있다.
  - 마린은 정상적으로 움직이는 메서드, 공격메서드를 구현하여
  움직이고 공격이 가능하다.
  - 배틀크루져는 움직이는 메서드는 구현하였지만, 
  공격 메서드는 구현하지 않았다.
  - 이렇게 `일반` 클래스는 부모 클래스의 기능을 그대로 상속하므로,
  실수로 메서드를 빼놓고 구현할 수 있다.
  - 이 경우, 실제로 게임을 실행해서 배틀크루져가 공격을 실행했을 때,
  오류를 발견할 수 있다.
  - 기능을 일일히 추적하면서 찾아야 하므로, 오류를 발견하더라도 찾기가 힘들다
  
> 추상 클래스는 위와 같은 실수를 방지할 수 있다.

- `abstract` 구문을 사용한 메서드와 사용하지 않은 메서드를 구분한다.
## 📚 추상클래스의 일반 메서드
- `추상 클래스`의 `일반 메서드`는 이 추상 클래스를 상속받는 모든 클래스의 큰 흐름
`알고리즘`을 선언한다.
  - 유닛은 움직인 다음 공격한다는 알고리즘을 
  일반 메서드를 통해 표현할 수 있다.
## 📚 추상클래스의 추상 메서드
- `abstract` 구문을 사용한 메서드는 `추상 클래스`에서 선언하고, 
이 추상 클래스를 상속받은 `자식클래스`에서 구현하는 것을 강제한다.
  - 위 `유닛 클래스` 공격 메서드를 `추상 메서드`로 선언해 놓으면, 
  배틀크루저의 공격기능을 배틀크루저 클래스 내에서 무조건 구현하게 강제한다.
- 즉, 자식 클래스가 무조건 메서드를 구현하게끔 강제하는 것이 목적이다.
  

# ⭐ 추상 클래스와 인터페이스의 차이
## 목적의 차이
> `인터페이스`의 `구현` 객체가 달라져도, 
`인터페이스`를 `사용`하는 클래스에서는 코드의 변화가 일어나게 하지 않는다.

- `인터페이스`의 경우, `인터페이스`를 `구현`하는 클래스와 인터페이스를 `사용`하는 클래스로 나뉜다.
  - `인터페이스`를 `사용`하는 곳에서는 인터페이스를 `구현`한 클래스에 따라서 코드의 변화가 일어나지 않는다.
  - 단지 `인터페이스`에 새로운 `구현객체`를 할당하는 것으로, 다른 기능을 넣을 수 있다.
- `인터페이스`의 목적은 위와 같이 이 `인터페이스`를 `구현`한 객체는 모두 같은 이름의 메서드를 가지고 있고, `사용`하는 `클래스`에서는 `게임기의 버튼`을 누르는 것처럼 `항상 같은 이름`으로 `메서드`를 사용가능하게 만든다는 것이다.
  - 즉, `인터페이스`를 `사용`하는 클래스에서는 버튼 누르듯 항상 같은 메서드를 사용할 수 있다는 것이다.
  
> 클래스의 특정 기능을 자식 클래스에서 무조건 `구현`하게 `강제` 하는 것이 목적

- `추상클래스`의 경우, 특정 기능을 `하위클래스`에서 `구현`하는 것을 `강제`하는 것이 목적이다.
  - 상속관계가 성립하기 때문에, 공통된 멤버 변수를 가질 수 있다.
  - `추상 메서드` 말고, 새로운 `일반 메서드`를 넣을 수 있다.

>  즉, `메서드`의 `구현`을 다른 클래스에게 `강제`하는 공통된 특징을 가진다.
- `추상클래스`는 `부모 클래스`의 `특정` 기능을 자식클래스가 `구현`하도록 강제한다.
- `인터페이스`는 `인터페이스`의 `모든` 기능을 `인터페이스`를 `구현`하는 클래스가 `구현`하도록 강제한다.

## 문법적 차이
> 인터페이스와 추상클래스는 문법적으로 유사하므로, 차이점을 알아둘 필요가 있다.

- `폐쇄성`
  - `인터페이스`의 모든 메서드는 `public`이여야한다.
  - `추상 클래스`는 `private` 메서드를 선언할 수 있다.
- `변수`
  - `인터페이스`는 `상수`만 선언이 가능하다
    - 이 값은 바꿀수 없다.
  - `추상클래스`는 일반 클래스처럼 변수 선언이 가능하다.
- `다중상속`
  - `인터페이스`를 하나의 `구현 클래스`에서 여러 개 `구현`하는 것이 가능하다
    - 실질적으로 `부모자식관계`를 가지게 되는 것이 아니라, `다중 구현`이라고 표현하는 것이 `적절`하다.
  - `추상클래스`는 하나의 `클래스`만 `상속`이 가능하다



