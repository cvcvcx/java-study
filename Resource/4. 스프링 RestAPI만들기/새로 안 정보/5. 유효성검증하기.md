---
날짜: 2024-01-05
주제: Spring Boot REST API
설명: 서버 요청 객체의 유효성을 검증한다
---
> [!NOTE] 사용 시기
>  - 사용자의 요청이 이상하게 올 때, 
>    그 요청이 제대로 된 요청인지 아닌지 판별해서 예외처리를 해야한다.


> [!tip] 사용방법
> - spring-boot-starter-validation를 build.gradle에 추가하고
> - @Vaild 어노테이션을 사용해서 요청을 검증한다.
> - @Size @Past 와 같은 어노테이션으로 검증 기준을 정할 수 있다.
> - 또한, 이전에 만든 예외처리 정보 핸들러([[4. 예외처리 정보 커스텀하기]]참조)를 통해 
>   구체적인 메세지를 사용자에게 넘겨서, 조건을 알려줄 수 있다.


# 🚀 구체적인 사용방법
### 1. spring-boot-starter-validation 추가
 ```gradle
 // build.gradle
 implementation 'org.springframework.boot:spring-boot-starter-validation'
 ```

### 2. 매개변수에 @Valid 어노테이션 추가
```java
@PostMapping("/users")  
public ResponseEntity<User> createUser(@Valid @RequestBody User user){  
    User save = service.save(user);  
    URI location =  
            ServletUriComponentsBuilder.fromCurrentRequest()  
                                         .path("/{id}")  
                                         .buildAndExpand(save.getId())  
                                         .toUri();  
    return ResponseEntity.created(location).build();  
}
```

### 3. User객체에 조건 기준 어노테이션 추가
```java
@Getter  
@Setter  
@NoArgsConstructor  
@AllArgsConstructor  
@ToString  
public class User {  
    private Integer id;  
    //최소 2자이상은 입력해야한다.
    @Size(min = 2)  
    private String name;  
    // 현재일 기준 과거만 선택 가능하다
    @Past  
    private LocalDate birthDate;  
}
```

여기까지 하면 아래와 같은 결과를 볼 수 있다.
![](https://i.imgur.com/dQiSV4q.png)

- 하지만 디테일에서 구체적으로 어떤부분이 잘못되었는지 알려주었으면 좋겠다.
- 에러메세지를 전달하기 위해 이전에 만들었던 커스텀에러핸들러를 수정한다.
### 4. 커스텀에러핸들러에 에러처리 오버라이드 구현
```java
// 메서드의 인자가 유효하지 않을 때 발생하는 에러처리 메서드를 오버라이드해서 구현한다.
@Override  
protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {  
    ErrorDetails errorDetails =  
            new ErrorDetails(LocalDateTime.now(),  
                    ex.getMessage(),  
                    request.getDescription(false));  
    return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);  
}
```
수정한뒤 요청을 다시 보내면 아래와 같이 메세지가 도착한다
```
"message": "Validation failed for argument [0] in public org.springframework.http.ResponseEntity<com.in28minutes.rest.webservices.restfulwebservices.user.User> com.in28minutes.rest.webservices.restfulwebservices.user.UserResource.createUser(com.in28minutes.rest.webservices.restfulwebservices.user.User): [Field error in object 'user' on field 'birthDate': rejected value [2099-01-05]; codes [Past.user.birthDate,Past.birthDate,Past.java.time.LocalDate,Past]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [user.birthDate,birthDate]; arguments []; default message [birthDate]]; default message [과거 날짜여야 합니다]] ",
```
- 위와 같이, 에러가 어떤부분에서 발생했는지, 어떻게 수정해야하는지 정보를 전달하고있다.
- 하지만 너무 정보가 많아서 어떤 부분이 문제인지 파악하기 힘듬
- 위 메세지를 커스텀해서 알아보기 쉽게 만들자

### 5. 에러 메세지 커스텀
```java
//User.java
@Getter  
@Setter  
@NoArgsConstructor  
@AllArgsConstructor  
@ToString  
public class User {  
    private Integer id;  
    //메세지를 추가해서 어떤 오류메세지를 보여줄지 알려준다
    @Size(min = 2,message = "이름은 두글자 이상이어야 합니다!")  
    private String name;  
    @Past(message = "생일은 지금보다 미래일 수 없습니다!")  
    private LocalDate birthDate;  
}
```

```java

@Override  
protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {  
// ex에는 FieldError를 가져오는 메서드가 있고, 그곳에서 지정한 디폴트메세지를 가져와서 보여줄 수 있다.
    ErrorDetails errorDetails =  
            new ErrorDetails(LocalDateTime.now(),  
                    ex.getFieldError().getDefaultMessage(),  
                    request.getDescription(false));  
    return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);  
}
//CustomizedResponseErrorHandler.java
```

![](https://i.imgur.com/gVs8kq7.png)


> [!warning] 주의 사항

